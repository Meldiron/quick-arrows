<!doctype html>
<html lang="en" style="background-color: #222529">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quick Arrows | Cognitive minigame</title>
    <link rel="icon" href="/favicon.png" type="image/png" />
    <script src="https://www.unpkg.com/odyc@0.0.101/dist/index.global.js"></script>
  </head>
  <body>
    <script>
      const up = `
        .......
        ...x...
        ..xxx..
        .xxxxx.
        ...x...
        ...x...
        .......
        `;

      const down = `
        .......
        ...x...
        ...x...
        .xxxxx.
        ..xxx..
        ...x...
        .......
        `;

      const left = `
        .......
        ...x...
        ..xx...
        .xxxxx.
        ..xx...
        ...x...
        .......
        `;

      const right = `
        .......
        ...x...
        ...xx..
        .xxxxx.
        ...xx...
        ...x...
        .......
        `;

      const COLOR_SAME = "3";
      const COLOR_OPPOSITE = "5";
      const COLOR_NEXT = "7";

      function generateArrow() {
        const directions = ["up", "down", "left", "right"];
        const randomDirection =
          directions[Math.floor(Math.random() * directions.length)];

        const easyColors = [
          COLOR_SAME,
          COLOR_SAME,
          COLOR_SAME,
          COLOR_SAME,
          COLOR_SAME,
          COLOR_SAME,
          COLOR_SAME,
          COLOR_SAME,
          COLOR_OPPOSITE,
          COLOR_OPPOSITE,
          COLOR_OPPOSITE,
          COLOR_OPPOSITE,
          COLOR_NEXT,
        ];
        const mediumColors = [
          COLOR_SAME,
          COLOR_SAME,
          COLOR_SAME,
          COLOR_SAME,
          COLOR_SAME,
          COLOR_OPPOSITE,
          COLOR_OPPOSITE,
          COLOR_NEXT,
        ];
        const hardColors = [COLOR_SAME, COLOR_OPPOSITE, COLOR_NEXT];
        const colors =
          score < 30 ? easyColors : score < 40 ? mediumColors : hardColors;

        const randomColor = colors[Math.floor(Math.random() * colors.length)];

        let sprite;
        switch (randomDirection) {
          case "up":
            sprite = up;
            break;
          case "down":
            sprite = down;
            break;
          case "left":
            sprite = left;
            break;
          case "right":
            sprite = right;
            break;
          default:
            throw new Error("Unknown direction: " + direction);
        }

        return {
          direction: randomDirection,
          color: randomColor,
          sprite: sprite.split("x").join(randomColor),
        };
      }

      function getCorrectAnswer(arrow) {
        if (arrow.color === COLOR_SAME) {
          return arrow.direction;
        } else if (arrow.color === COLOR_OPPOSITE) {
          switch (arrow.direction) {
            case "up":
              return "down";
            case "down":
              return "up";
            case "left":
              return "right";
            case "right":
              return "left";
          }
        } else if (arrow.color === COLOR_NEXT) {
          const nextArrow = arrows[arrows.indexOf(arrow) + 1];
          if (!nextArrow) {
            throw new Error("No next arrow found");
          }
          return nextArrow.direction;
        } else {
          throw new Error("Unknown color: " + arrow.color);
        }
      }

      let score = 0;

      let arrows = []; // lowest on screen = in array first
      function renderArrows() {
        while (arrows.length < 2) {
          arrows.push(generateArrow());
        }
        let i = 0;
        for (const arrow of arrows) {
          game.setCell(1, 1 - i, arrow);
          i++;
        }
      }

      const game = odyc.createGame({
        background: "#222529",
        dialogInternvalMs: 15,
        controls: {
          LEFT: ["KeyA", "ArrowLeft"],
          RIGHT: ["KeyD", "ArrowRight"],
          UP: ["KeyW", "ArrowUp"],
          DOWN: ["KeyS", "ArrowDown"],
          ACTION: ["Enter", "Space"],
        },
        cellWidth: 7,
        cellHeight: 7,
        screenWidth: 3,
        screenHeight: 3,
        player: {
          sprite: ``,
          position: [1, 1],
        },
        templates: {
          a: {
            solid: false,
            sprite: 0,
          },
          t: {
            solid: false,
            sprite: `
                    .......
                    .......
                    .......
                    .......
                    .......
                    .......
                    1111111
                `,
          },
          c: {
            visible: false,
            onTurn: () => {
              const pos = game.player.position;
              game.player.position = [1, 1];

              let direction;
              if (pos[0] === 0 && pos[1] === 1) {
                direction = "left";
              } else if (pos[0] === 2 && pos[1] === 1) {
                direction = "right";
              } else if (pos[0] === 1 && pos[1] === 0) {
                direction = "up";
              } else if (pos[0] === 1 && pos[1] === 2) {
                direction = "down";
              } else {
                alert("Wrong direction");
              }

              const correctAnswer = getCorrectAnswer(arrows[0]);

              if (direction === correctAnswer) {
                arrows.shift();
                renderArrows();
                score++;
                resetTimer();
              } else {
                gameOver([
                  `You pressed <8>${direction}<8>, but the correct action was <8>${correctAnswer}<8>.`,
                  `Your score was <8>${score}<8> points. Thanks for playing.`,
                ]);
              }
            },
          },
        },
        map: `
            ca.
            .a.
            ttt
            `,
      });

      let timeLeft = 21; // max 21
      let timer;

      function renderTimer() {
        for (let i = 0; i < 3; i++) {
          const startingJ = i * 7 + 1;
          const colors = [];

          for (let j = startingJ; j <= startingJ + 7; j++) {
            const color = j <= timeLeft ? "1" : "0";
            colors.push(color);
          }

          game.setCell(i, 2, {
            sprite: `
                    .......
                    .......
                    .......
                    .......
                    .......
                    .......
                    ${colors.join("")}
                    `,
          });
        }
      }

      async function gameOver(msgs) {
        if (timer) {
          clearInterval(timer);
        }

        arrows = [];
        for (const msg of msgs) {
          await game.openDialog(msg);
        }
        
        if (score > bestScore) {
          await game.openDialog(
            `Your new best score is <8>${score}<8>, from previous <8>${bestScore}<8> points.`
          );
        }

        for (let i = 0; i < 3; i++) {
          game.setCell(1, i, {
            solid: false,
            sprite: null,
          });
        }
        showTitleScreen();
      }

      function resetTimer() {
        let timerSpeed =
          score < 5
            ? 250
            : score < 10
              ? 200
              : score < 15
                ? 150
                : score < 20
                  ? 100
                  : score < 100
                    ? 70
                    : null;
        if (timerSpeed === null) {
          timerSpeed =
            score < 200
              ? 60
              : score < 300
                ? 50
                : score < 400
                  ? 40
                  : score < 500
                    ? 30
                    : 20;
        }

        timeLeft = 21;
        renderTimer();

        if (timer) {
          clearInterval(timer);
        }

        function timerTick() {
          timeLeft--;
          if (timeLeft <= 0) {
            gameOver([
              "You ran out of time. Your score was <8>" + score + "<8> points.",
            ]);
          }
        }

        timer = setInterval(() => {
          timerTick();
        }, timerSpeed);
      }

      async function timerRenderFrame() {
        if (timer) {
          renderTimer();
        }

        setTimeout(() => {
          requestAnimationFrame(timerRenderFrame);
        }, 100);
      }
      requestAnimationFrame(timerRenderFrame);

      let bestScore = +(localStorage.getItem("score") || "0");
      async function showTitleScreen() {
        if (score > bestScore) {
          bestScore = score;
          localStorage.setItem("score", `${bestScore}`);
        }

        await game.openMessage(
          `Quick arrows\n<2>(cognitive minigame)<2>\n\n\n<3>Do the direction<3>\n<5>Opposite direction<5>\n<7>Same as arrow above<7>\n\n\nBest score: ${bestScore}\n\n\n<2>Controls: WASD/Swipe<2>\n<2>Press SPACE to start.<2>`
        );
        score = 0;
        renderArrows();
        resetTimer();
      }

      showTitleScreen();
    </script>
  </body>
</html>
